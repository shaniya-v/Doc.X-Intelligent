{
  "name": "DOC.X Intelligent - Multi-Platform Document Processor",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 3
            }
          ]
        }
      },
      "id": "main-scheduler",
      "name": "Multi-Platform Scanner",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [
        200,
        400
      ]
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "getAll",
        "returnAll": false,
        "limit": 10,
        "simple": false,
        "options": {
          "q": "is:unread (from:kmrl.co.in OR from:maximo@kmrl.co.in OR subject:(KMRL OR à´•àµ†à´à´‚à´†àµ¼à´àµ½ OR \"Kochi Metro\" OR \"à´•àµŠà´šàµà´šà´¿ à´®àµ†à´Ÿàµà´°àµ‹\") OR from:noreply@kmrl.co.in OR from:admin@kmrl.co.in OR from:operations@kmrl.co.in OR from:engineering@kmrl.co.in OR from:finance@kmrl.co.in OR from:hr@kmrl.co.in OR from:safety@kmrl.co.in) newer_than:1d",
          "includeAttachments": true,
          "format": "full",
          "attachments": true,
          "downloadAttachments": true
        }
      },
      "id": "gmail-processor",
      "name": "ğŸ“§ Gmail Scanner",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2,
      "position": [
        450,
        250
      ]
    },
    {
      "parameters": {
        "url": "https://kmrlcoin.sharepoint.com/_api/web/lists/getbytitle('KMRL Documents')/items?$filter=Modified ge datetime'{{ $now.minus({days: 1}).toISO() }}'",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOutlookOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "sharepoint-scanner",
      "name": "ğŸ“ SharePoint Scanner",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        450,
        400
      ]
    },
    {
      "parameters": {
        "url": "{{ $parameter.maximoApiUrl }}/api/os/mxasset",
        "authentication": "predefinedCredentialType", 
        "nodeCredentialType": "httpBasicAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "oslc.where",
              "value": "changedate>=\"{{ $now.minus({days: 1}).toISO() }}\""
            },
            {
              "name": "oslc.select", 
              "value": "assetnum,description,location,status,changedate"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "maximo-scanner",
      "name": "ğŸ”§ Maximo Scanner",
      "type": "n8n-nodes-base.httpRequest", 
      "typeVersion": 4.2,
      "position": [
        450,
        550
      ]
    },
    {
      "parameters": {
        "url": "{{ $parameter.whatsappApiUrl }}/api/messages",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "filter",
              "value": "hasDocument=true&after={{ $now.minus({hours: 6}).toISO() }}"
            }
          ]
        }
      },
      "id": "whatsapp-scanner", 
      "name": "ğŸ“± WhatsApp Scanner",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        450,
        700
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.source }}",
              "rightValue": "gmail",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "id": "source-router",
      "name": "ğŸ¯ Source Router", 
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        700,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Gmail attachment processor for N8N Gmail node output\nconst items = $input.all();\nconst results = [];\n\n// Helper function to safely extract string from Gmail API response\nfunction safeString(value) {\n  if (typeof value === 'string') return value;\n  if (value && typeof value === 'object') {\n    // Handle N8N Gmail node address objects\n    if (value.value && Array.isArray(value.value) && value.value[0]) {\n      const addr = value.value[0];\n      return addr.name ? `${addr.name} <${addr.address}>` : addr.address;\n    }\n    if (value.text) return value.text;\n    if (value.emailAddress) return value.emailAddress;\n    if (value.name) return value.name;\n    return String(value);\n  }\n  return String(value || '');\n}\n\n// Check if email has multipart content indicating potential attachments\nfunction hasMultipartContent(headers) {\n  if (!headers || typeof headers !== 'object') return false;\n  \n  const contentType = headers['content-type'] || '';\n  return contentType.includes('multipart/mixed') || \n         contentType.includes('multipart/related') || \n         contentType.includes('multipart/alternative');\n}\n\n// Extract boundary from content-type header\nfunction extractBoundary(headers) {\n  if (!headers || typeof headers !== 'object') return null;\n  \n  const contentType = headers['content-type'] || '';\n  const boundaryMatch = contentType.match(/boundary=\"?([^\"\\s;]+)\"?/);\n  return boundaryMatch ? boundaryMatch[1] : null;\n}\n\n// KMRL-specific filter function\nfunction isKMRLRelated(data) {\n  const fromEmail = safeString(data.from).toLowerCase();\n  const subject = safeString(data.subject).toLowerCase();\n  const snippet = safeString(data.text || data.html || '').toLowerCase();\n  \n  console.log(`ğŸ” Checking KMRL relevance:`);\n  console.log(`  From: ${fromEmail}`);\n  console.log(`  Subject: ${subject}`);\n  \n  // Check from domain\n  if (fromEmail.includes('kmrl.co.in') || fromEmail.includes('maximo@kmrl')) {\n    console.log(`âœ… KMRL domain detected in from address`);\n    return true;\n  }\n  \n  // Check subject for KMRL indicators\n  const kmrlIndicators = [\n    'kmrl', 'à´•àµ†à´à´‚à´†àµ¼à´àµ½', 'kochi metro', 'à´•àµŠà´šàµà´šà´¿ à´®àµ†à´Ÿàµà´°àµ‹',\n    'metro rail', 'à´®àµ†à´Ÿàµà´°àµ‹ à´±àµ†à´¯à´¿àµ½', 'maintanance', 'maintenance'\n  ];\n  \n  for (const indicator of kmrlIndicators) {\n    if (subject.includes(indicator) || snippet.includes(indicator)) {\n      console.log(`âœ… KMRL indicator '${indicator}' found in subject/content`);\n      return true;\n    }\n  }\n  \n  // Check for KMRL-specific operational terms (only if combined with location indicators)\n  const operationalTerms = ['maintenance', 'safety', 'incident', 'repair', 'maintanance'];\n  const locationTerms = ['ernakulam', 'aluva', 'kochi', 'platform', 'station', 'track', 'à´à´±à´£à´¾à´•àµà´³à´‚', 'à´•àµŠà´šàµà´šà´¿'];\n  \n  const hasOperational = operationalTerms.some(term => subject.includes(term) || snippet.includes(term));\n  const hasLocation = locationTerms.some(term => subject.includes(term) || snippet.includes(term));\n  \n  if (hasOperational && hasLocation) {\n    console.log(`âœ… KMRL operational + location terms found`);\n    return true;\n  }\n  \n  console.log(`âŒ No KMRL indicators found`);\n  return false;\n}\n\nfor (const item of items) {\n  const data = item.json;\n  const binary = item.binary || {};\n  \n  console.log(`\\n=== Processing Gmail Message ===`);\n  console.log(`ğŸ“§ Subject: ${safeString(data.subject)}`);\n  console.log(`ğŸ‘¤ From: ${safeString(data.from)}`);\n  console.log(`ğŸ†” Message ID: ${data.id}`);\n  console.log(`ğŸ“ Size: ${data.sizeEstimate} bytes`);\n  console.log(`ğŸ”— Has binary data: ${Object.keys(binary).length > 0}`);\n  console.log(`ğŸ“ Binary keys: ${Object.keys(binary)}`);\n  \n  // Apply KMRL filter first\n  if (!isKMRLRelated(data)) {\n    console.log(`â­ï¸ Skipping non-KMRL email`);\n    continue;\n  }\n  \n  console.log(`ğŸ¯ KMRL-related email detected!`);\n  \n  let hasProcessedAttachments = false;\n  \n  // Method 1: Check if N8N extracted binary attachments (PRIORITY METHOD)\n  if (binary && Object.keys(binary).length > 0) {\n    console.log(`ğŸ“ Method 1: Found ${Object.keys(binary).length} binary attachments from N8N`);\n    \n    for (const [key, attachment] of Object.entries(binary)) {\n      if (attachment && (attachment.fileName || attachment.filename)) {\n        const fileName = attachment.fileName || attachment.filename;\n        console.log(`ğŸ“„ Processing binary attachment: ${fileName} (${attachment.fileSize || 0} bytes)`);\n        \n        results.push({\n          json: {\n            documentId: `gmail_${data.id}_${fileName}`,\n            filename: fileName,\n            mimeType: attachment.mimeType || 'application/octet-stream',\n            size: attachment.fileSize || 0,\n            downloadUrl: null, // Binary data, no URL needed\n            source: 'gmail',\n            parentMessage: {\n              id: data.id,\n              subject: safeString(data.subject),\n              from: safeString(data.from),\n              date: data.date\n            },\n            metadata: {\n              hasAttachment: true,\n              hasBinaryData: true,\n              binaryKey: key,\n              kmrlRelevance: 'confirmed',\n              language: 'unknown',\n              priority: 'normal'\n            }\n          },\n          binary: {\n            [key]: attachment\n          }\n        });\n        hasProcessedAttachments = true;\n      }\n    }\n  }\n  \n  // Method 2: Check if N8N processed attachments are available\n  // Method 2: Check if N8N processed attachments are available\n  if (!hasProcessedAttachments && data.attachments && Array.isArray(data.attachments) && data.attachments.length > 0) {\n    console.log(`ğŸ“ Method 2: Found ${data.attachments.length} N8N processed attachments`);\n    \n    for (const attachment of data.attachments) {\n      if (attachment.size && attachment.size > 0) {\n        const downloadUrl = attachment.downloadUrl || attachment.url || \n          (attachment.attachmentId ? `https://www.googleapis.com/gmail/v1/users/me/messages/${data.id}/attachments/${attachment.attachmentId}` : null);\n        \n        if (downloadUrl) {\n          console.log(`ğŸ“„ Processing attachment: ${attachment.filename} (${attachment.size} bytes)`);\n          \n          results.push({\n            json: {\n              documentId: `gmail_${data.id}_${attachment.filename}`,\n              filename: attachment.filename || 'attachment',\n              mimeType: attachment.mimeType || 'application/octet-stream',\n              size: attachment.size,\n              downloadUrl: downloadUrl,\n              source: 'gmail',\n              parentMessage: {\n                id: data.id,\n                subject: safeString(data.subject),\n                from: safeString(data.from),\n                date: data.date\n              },\n              metadata: {\n                hasAttachment: true,\n                attachmentId: attachment.attachmentId,\n                kmrlRelevance: 'confirmed',\n                language: 'unknown',\n                priority: 'normal'\n              }\n            }\n          });\n          hasProcessedAttachments = true;\n        }\n      }\n    }\n  }\n  \n  // Method 3: Check for multipart content indicating attachments\n  if (!hasProcessedAttachments && hasMultipartContent(data.headers)) {\n    console.log(`ğŸ“ Method 3: Multipart content detected - may contain attachments`);\n    const boundary = extractBoundary(data.headers);\n    console.log(`ï¿½ Content boundary: ${boundary}`);\n    \n    // Since N8N Gmail node doesn't expose raw multipart content,\n    // we'll create a placeholder for multipart content processing\n    console.log(`âš ï¸ Multipart content detected but N8N Gmail node doesn't expose raw parts`);\n    console.log(`ï¿½ Processing as email with potential attachments`);\n    \n    // Process as email content that likely has attachments\n    results.push({\n      json: {\n        documentId: `gmail_${data.id}_multipart`,\n        filename: `${safeString(data.subject) || 'KMRL Email'}.eml`,\n        content: data.html || data.text || '',\n        mimeType: 'message/rfc822',\n        downloadUrl: null,\n        source: 'gmail',\n        parentMessage: {\n          id: data.id,\n          subject: safeString(data.subject),\n          from: safeString(data.from),\n          date: data.date\n        },\n        metadata: {\n          hasAttachment: true, // Mark as having attachments based on multipart content\n          multipartBoundary: boundary,\n          kmrlRelevance: 'confirmed',\n          language: 'unknown',\n          priority: safeString(data.subject).toLowerCase().includes('urgent') ? 'urgent' : 'normal',\n          note: 'Multipart email - may contain attachments not processed by N8N Gmail node'\n        }\n      }\n    });\n    hasProcessedAttachments = true;\n  }\n  \n  // Method 4: Process as text email if no attachments detected\n  if (!hasProcessedAttachments) {\n    console.log(`ğŸ’¬ No attachments detected - processing as text email`);\n    \n    results.push({\n      json: {\n        documentId: `gmail_${data.id}_content`,\n        filename: `${safeString(data.subject) || 'KMRL Email'}.txt`,\n        content: data.text || data.html || '',\n        mimeType: data.html ? 'text/html' : 'text/plain',\n        downloadUrl: null,\n        source: 'gmail',\n        parentMessage: {\n          id: data.id,\n          subject: safeString(data.subject),\n          from: safeString(data.from),\n          date: data.date\n        },\n        metadata: {\n          hasAttachment: false,\n          kmrlRelevance: 'confirmed',\n          language: 'unknown',\n          priority: safeString(data.subject).toLowerCase().includes('urgent') || safeString(data.subject).toLowerCase().includes('à´…à´Ÿà´¿à´¯à´¨àµà´¤à´°') ? 'urgent' : 'normal'\n        }\n      }\n    });\n  }\n}\n\nconsole.log(`\\nğŸ¯ Gmail Processing Summary:`);\nconsole.log(`ğŸ“§ Total emails processed: ${items.length}`);\nconsole.log(`ğŸ“„ Documents created: ${results.length}`);\nconsole.log(`âœ… KMRL-related items: ${results.filter(r => r.json.metadata.kmrlRelevance === 'confirmed').length}`);\n\nreturn results;"
      },
      "id": "gmail-processor-code",
      "name": "ğŸ“§ Gmail Document Processor",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        250
      ]
    },
    {
      "parameters": {
        "jsCode": "// Process SharePoint documents\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const data = item.json;\n  \n  if (data.value && Array.isArray(data.value)) {\n    for (const doc of data.value) {\n      results.push({\n        json: {\n          documentId: `sharepoint_${doc.Id}`,\n          filename: doc.FileLeafRef || doc.Title,\n          downloadUrl: doc.FileRef ? `https://kmrlcoin.sharepoint.com${doc.FileRef}` : null,\n          mimeType: doc.File_x0020_Type || 'application/octet-stream',\n          source: 'sharepoint',\n          metadata: {\n            modified: doc.Modified,\n            author: doc.Author?.Title || 'Unknown',\n            size: doc.File_x0020_Size || 0,\n            language: 'unknown',\n            priority: 'normal'\n          },\n          parentLibrary: {\n            title: 'KMRL Documents',\n            url: doc.FileRef\n          }\n        }\n      });\n    }\n  }\n}\n\nreturn results;"
      },
      "id": "sharepoint-processor-code",
      "name": "ğŸ“ SharePoint Document Processor", 
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Process Maximo exports\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const data = item.json;\n  \n  if (data.member && Array.isArray(data.member)) {\n    for (const asset of data.member) {\n      results.push({\n        json: {\n          documentId: `maximo_${asset.assetnum}_${Date.now()}`,\n          filename: `maximo_export_${asset.assetnum}.json`,\n          content: JSON.stringify(asset, null, 2),\n          mimeType: 'application/json',\n          downloadUrl: null,\n          source: 'maximo',\n          metadata: {\n            assetNumber: asset.assetnum,\n            location: asset.location,\n            status: asset.status,\n            changeDate: asset.changedate,\n            description: asset.description,\n            language: 'english',\n            priority: asset.status === 'BROKEN' ? 'urgent' : 'normal'\n          },\n          parentSystem: {\n            name: 'Maximo',\n            type: 'Asset Management'\n          }\n        }\n      });\n    }\n  }\n}\n\nreturn results;"
      },
      "id": "maximo-processor-code",
      "name": "ğŸ”§ Maximo Document Processor",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        550
      ]
    },
    {
      "parameters": {
        "jsCode": "// Process WhatsApp documents\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const data = item.json;\n  \n  if (data.messages && Array.isArray(data.messages)) {\n    for (const message of data.messages) {\n      if (message.document) {\n        results.push({\n          json: {\n            documentId: `whatsapp_${message.id}`,\n            filename: message.document.filename || `whatsapp_doc_${message.id}.pdf`,\n            downloadUrl: message.document.downloadUrl,\n            mimeType: message.document.mimetype || 'application/pdf',\n            source: 'whatsapp',\n            metadata: {\n              chatId: message.chatId,\n              from: message.from,\n              timestamp: message.timestamp,\n              caption: message.caption,\n              language: 'unknown',\n              priority: message.caption?.includes('urgent') || message.caption?.includes('à´…à´Ÿà´¿à´¯à´¨àµà´¤à´°') ? 'urgent' : 'normal'\n            },\n            parentChat: {\n              id: message.chatId,\n              participant: message.from\n            }\n          }\n        });\n      }\n    }\n  }\n}\n\nreturn results;"
      },
      "id": "whatsapp-processor-code",
      "name": "ğŸ“± WhatsApp Document Processor",
      "type": "n8n-nodes-base.code", 
      "typeVersion": 2,
      "position": [
        900,
        700
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.downloadUrl }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "isNotEmpty"
              }
            },
            {
              "leftValue": "={{ $json.downloadUrl }}",
              "rightValue": "null",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            },
            {
              "leftValue": "={{ $json.downloadUrl }}",
              "rightValue": "undefined",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            },
            {
              "leftValue": "={{ $json.metadata?.hasAttachment }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "or"
        }
      },
      "id": "has-download-url",
      "name": "ğŸ“¥ Has Download URL or Attachment?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1150,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare documents for download or direct processing\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const json = item.json;\n  const binary = item.binary || {};\n  \n  console.log(`ğŸ”„ Preparing document: ${json.filename}`);\n  console.log(`ğŸ“¥ Download URL: ${json.downloadUrl}`);\n  console.log(`ğŸ“ Has attachment: ${json.metadata?.hasAttachment}`);\n  console.log(`ğŸ’¾ Has binary data: ${json.metadata?.hasBinaryData}`);\n  console.log(`ğŸ”— Binary keys: ${Object.keys(binary)}`);\n  \n  // Check if we already have binary data (from email attachments)\n  if (json.metadata?.hasBinaryData && Object.keys(binary).length > 0) {\n    console.log(`ğŸ“ Document already has binary data - ready for backend`);\n    // Binary attachment is already processed, just pass it through\n    results.push({\n      json: {\n        ...json,\n        processingType: 'binary',\n        needsDownload: false\n      },\n      binary: binary\n    });\n  }\n  // Check if we have a valid download URL\n  else if (json.downloadUrl && json.downloadUrl !== 'null' && json.downloadUrl !== '' && json.downloadUrl !== 'undefined') {\n    console.log(`ğŸ“ Document has download URL - will download file`);\n    // Mark for actual download\n    results.push({\n      json: {\n        ...json,\n        processingType: 'download',\n        needsDownload: true\n      }\n    });\n  } else {\n    console.log(`ğŸ“§ Document is content-only - creating virtual file`);\n    \n    // Create virtual binary data for email content\n    const emailContent = json.content || '';\n    const contentBuffer = Buffer.from(emailContent, 'utf8');\n    \n    const virtualBinary = {\n      data: {\n        data: contentBuffer.toString('base64'),\n        mimeType: json.mimeType || 'text/html',\n        fileName: json.filename,\n        fileSize: contentBuffer.length\n      }\n    };\n    \n    console.log(`ğŸ“„ Created virtual file: ${json.filename} (${contentBuffer.length} bytes)`);\n    \n    // Mark as already processed with virtual binary\n    results.push({\n      json: {\n        ...json,\n        processingType: 'content',\n        needsDownload: false\n      },\n      binary: virtualBinary\n    });\n  }\n}\n\nconsole.log(`ğŸ¯ Prepared ${results.length} documents`);\nreturn results;"
      },
      "id": "prepare-documents",
      "name": "ğŸ”„ Prepare Documents",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        400
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.needsDownload }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            },
            {
              "leftValue": "={{ $json.downloadUrl }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "isNotEmpty"
              }
            },
            {
              "leftValue": "={{ $json.downloadUrl }}",
              "rightValue": "null",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "needs-download-check",
      "name": "ğŸ“¥ Needs Download?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1350,
        400
      ]
    },
    {
      "parameters": {
        "url": "={{ (typeof $json.downloadUrl === 'string' && $json.downloadUrl.trim() !== '' && $json.downloadUrl !== 'null' && $json.downloadUrl !== 'undefined' && $json.downloadUrl.includes('http')) ? $json.downloadUrl : 'https://httpbin.org/status/204' }}",
        "sendHeaders": false,
        "options": {
          "redirect": {
            "redirect": {
              "followRedirects": true,
              "maxRedirects": 21
            }
          },
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "data"
            }
          },
          "timeout": 10000
        }
      },
      "id": "download-document",
      "name": "ğŸ“¥ Download Document",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1500,
        350
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare document for backend processing\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const json = item.json;\n  const binary = item.binary || {};\n  \n  console.log(`\\nğŸ”„ Preparing document for backend:`);\n  console.log(`ğŸ“„ Document ID: ${json.documentId}`);\n  console.log(`ğŸ“ Filename: ${json.filename}`);\n  console.log(`ğŸ”— Has binary: ${Object.keys(binary).length > 0}`);\n  console.log(`ğŸ“ Has text content: ${!!json.content}`);\n  console.log(`ğŸŒ Download URL: ${!!json.downloadUrl}`);\n  \n  // Prepare document data for DOC.X backend\n  const documentData = {\n    documentId: json.documentId,\n    filename: json.filename,\n    source: json.source,\n    mimeType: json.mimeType,\n    metadata: json.metadata || {},\n    downloadUrl: json.downloadUrl || null,\n    parentMessage: json.parentMessage || null,\n    parentLibrary: json.parentLibrary || null,\n    parentSystem: json.parentSystem || null,\n    parentChat: json.parentChat || null,\n    timestamp: new Date().toISOString()\n  };\n  \n  // Handle content extraction based on available data\n  if (json.content && json.content.trim()) {\n    // Direct text content available (email content, extracted text)\n    documentData.content = json.content;\n    documentData.contentSource = 'direct';\n    console.log(`âœ… Using direct text content (${json.content.length} chars)`);\n  } else if (Object.keys(binary).length > 0) {\n    // Binary attachment available - send for backend processing\n    documentData.content = null; // Will be extracted by backend\n    documentData.contentSource = 'binary';\n    documentData.hasBinary = true;\n    documentData.binaryKeys = Object.keys(binary);\n    \n    // Add binary file metadata\n    const firstBinaryKey = Object.keys(binary)[0];\n    const binaryData = binary[firstBinaryKey];\n    if (binaryData) {\n      documentData.fileSize = binaryData.fileSize || binaryData.data?.length || 0;\n      documentData.mimeType = binaryData.mimeType || documentData.mimeType;\n    }\n    \n    console.log(`ğŸ“ Using binary attachment for processing`);\n    console.log(`ğŸ—‚ï¸ Binary keys: ${Object.keys(binary).join(', ')}`);\n  } else if (json.downloadUrl) {\n    // Download URL available - backend will fetch and process\n    documentData.content = null; // Will be downloaded and extracted by backend\n    documentData.contentSource = 'download';\n    console.log(`ğŸŒ Using download URL for processing`);\n  } else {\n    // Fallback - use any available text\n    const fallbackContent = json.text || json.html || json.snippet || '';\n    documentData.content = fallbackContent;\n    documentData.contentSource = 'fallback';\n    console.log(`âš ï¸ Using fallback content (${fallbackContent.length} chars)`);\n  }\n  \n  results.push({\n    json: documentData,\n    binary: binary\n  });\n  \n  console.log(`âœ… Document prepared with content source: ${documentData.contentSource}`);\n}\n\nconsole.log(`\\nğŸ¯ Backend Preparation Summary:`);\nconsole.log(`ğŸ“„ Total documents prepared: ${results.length}`);\nconsole.log(`ğŸ“ Documents with binary: ${results.filter(r => r.json.hasBinary).length}`);\nconsole.log(`ğŸ“ Documents with direct content: ${results.filter(r => r.json.contentSource === 'direct').length}`);\n\nreturn results;"
      },
      "id": "prepare-for-backend",
      "name": "ğŸ”„ Prepare for Backend",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1550,
        400
      ]
    },
    {
      "parameters": {
        "url": "http://127.0.0.1:5000/webhook/store-document",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type", 
              "value": "application/json"
            }
          ]
        },
        "sendBinaryData": true,
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        }
      },
      "id": "send-to-docx-backend",
      "name": "ï¿½ Store Document (Stage 1)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1750,
        400
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.status }}",
              "rightValue": "success",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ]
        }
      },
      "id": "check-processing-success",
      "name": "âœ… Processing Success?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1950,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Log successful processing\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const data = item.json;\n  const document = data.document || {};\n  \n  console.log(`âœ… SUCCESS: Document ${document.id} processed`);\n  console.log(`ğŸ¯ Department: ${document.assigned_department}`);\n  console.log(`ğŸŒ Language: ${document.language}`);\n  console.log(`ğŸ“Š Confidence: ${document.confidence}%`);\n  console.log(`ğŸ”¥ Priority: ${document.priority}`);\n  \n  results.push({\n    json: {\n      status: 'logged',\n      documentId: document.id,\n      department: document.assigned_department,\n      language: document.language,\n      confidence: document.confidence,\n      priority: document.priority,\n      timestamp: new Date().toISOString()\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "log-success",
      "name": "ğŸ“ Log Success",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2150,
        350
      ]
    },
    {
      "parameters": {
        "jsCode": "// Log processing errors\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const data = item.json;\n  \n  console.log(`âŒ ERROR: Document processing failed`);\n  console.log(`ğŸ“„ Document: ${data.documentId || 'Unknown'}`);\n  console.log(`ğŸ” Source: ${data.source || 'Unknown'}`);\n  console.log(`âš ï¸ Error: ${data.message || 'Unknown error'}`);\n  \n  results.push({\n    json: {\n      status: 'error_logged',\n      documentId: data.documentId,\n      source: data.source,\n      error: data.message,\n      timestamp: new Date().toISOString()\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "log-error",
      "name": "âŒ Log Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2150,
        450
      ]
    },
    {
      "parameters": {},
      "id": "no-download-skip",
      "name": "â­ï¸ No Download - Process Content",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        1350,
        450
      ]
    }
  ],
  "connections": {
    "Multi-Platform Scanner": {
      "main": [
        [
          {
            "node": "ğŸ“§ Gmail Scanner",
            "type": "main",
            "index": 0
          },
          {
            "node": "ğŸ“ SharePoint Scanner", 
            "type": "main",
            "index": 0
          },
          {
            "node": "ğŸ”§ Maximo Scanner",
            "type": "main", 
            "index": 0
          },
          {
            "node": "ğŸ“± WhatsApp Scanner",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“§ Gmail Scanner": {
      "main": [
        [
          {
            "node": "ğŸ“§ Gmail Document Processor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“ SharePoint Scanner": {
      "main": [
        [
          {
            "node": "ğŸ“ SharePoint Document Processor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”§ Maximo Scanner": {
      "main": [
        [
          {
            "node": "ğŸ”§ Maximo Document Processor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“± WhatsApp Scanner": {
      "main": [
        [
          {
            "node": "ğŸ“± WhatsApp Document Processor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“§ Gmail Document Processor": {
      "main": [
        [
          {
            "node": "ğŸ“¥ Has Download URL or Attachment?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“ SharePoint Document Processor": {
      "main": [
        [
          {
            "node": "ğŸ“¥ Has Download URL or Attachment?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”§ Maximo Document Processor": {
      "main": [
        [
          {
            "node": "ğŸ“¥ Has Download URL or Attachment?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“± WhatsApp Document Processor": {
      "main": [
        [
          {
            "node": "ğŸ“¥ Has Download URL or Attachment?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“¥ Has Download URL or Attachment?": {
      "main": [
        [
          {
            "node": "ï¿½ Prepare Documents",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "â­ï¸ No Download - Process Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”„ Prepare Documents": {
      "main": [
        [
          {
            "node": "ğŸ“¥ Needs Download?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“¥ Needs Download?": {
      "main": [
        [
          {
            "node": "ğŸ“¥ Download Document",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ğŸ”„ Prepare for Backend",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“¥ Download Document": {
      "main": [
        [
          {
            "node": "ğŸ”„ Prepare for Backend",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "â­ï¸ No Download - Process Content": {
      "main": [
        [
          {
            "node": "ğŸ”„ Prepare for Backend",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”„ Prepare for Backend": {
      "main": [
        [
          {
            "node": "ğŸš€ Send to DOC.X Backend",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸš€ Send to DOC.X Backend": {
      "main": [
        [
          {
            "node": "âœ… Processing Success?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "âœ… Processing Success?": {
      "main": [
        [
          {
            "node": "ğŸ“ Log Success",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "âŒ Log Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": ["KMRL", "Multi-Platform", "Document Processing"],
  "triggerCount": 1,
  "updatedAt": "2025-10-03T11:30:00.000Z",
  "versionId": "multi-platform-v2.0"
}