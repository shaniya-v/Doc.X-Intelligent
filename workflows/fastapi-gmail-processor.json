{
  "name": "Doc.X Gmail Processor - Unread with Read Marking",
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "filters": {},
        "options": {
          "downloadAttachments": true,
          "q": "label:KMRL is:unread has:attachment"
        }
      },
      "id": "gmail-trigger",
      "name": "Gmail Trigger - Unread KMRL",
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1,
      "position": [250, 300]
    },

    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{Object.keys($binary).length}}",
              "operation": "isNotEmpty"
            }
          ]
        }
      },
      "id": "filter-attachments",
      "name": "Filter - Has Attachments",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "jsCode": "try {\n  const items = $input.all();\n  console.log('\\nüîç EXTRACTION START');\n  console.log('Input items:', items.length);\n  \n  const allResults = [];\n  \n  for (const item of items) {\n    const data = item.json || {};\n    const binary = item.binary || {};\n    \n    console.log('\\nüìß Email ID:', data.id);\n    console.log('Subject:', data.Subject || data.subject);\n    console.log('From:', data.From || data.from);\n    console.log('Binary keys:', Object.keys(binary));\n    \n    // Extract metadata\n    const messageId = data.id || data.messageId || '';\n    const emailFrom = data.From || data.from || 'Unknown';\n    const emailSubject = data.Subject || data.subject || 'No Subject';\n    const emailDate = data.internalDate || data.date || new Date().toISOString();\n    \n    // Check if there are any binary attachments\n    const binaryKeys = Object.keys(binary);\n    \n    if (binaryKeys.length === 0) {\n      console.log('‚ö†Ô∏è  No binary attachments found');\n      continue;\n    }\n    \n    console.log(`\\nüìé Found ${binaryKeys.length} attachments`);\n    \n    // Process each binary attachment\n    for (const key of binaryKeys) {\n      const attachment = binary[key];\n      \n      if (!attachment || !attachment.data) {\n        console.log(`‚è≠Ô∏è  Skipping ${key}: no data`);\n        continue;\n      }\n      \n      const filename = attachment.fileName || attachment.filename || key;\n      const mimeType = attachment.mimeType || attachment.mimetype || '';\n      const fileSize = attachment.fileSize || (attachment.data ? attachment.data.length : 0);\n      \n      console.log(`  - ${filename}`);\n      console.log(`    Type: ${mimeType}`);\n      console.log(`    Size: ${(fileSize/1024).toFixed(1)} KB`);\n      \n      // Check if it's a document type\n      const isDocument = \n        /\\.(pdf|docx?|xlsx?|xls|csv|txt)$/i.test(filename) ||\n        mimeType.includes('pdf') ||\n        mimeType.includes('document') ||\n        mimeType.includes('spreadsheet') ||\n        mimeType.includes('ms-word') ||\n        mimeType.includes('ms-excel') ||\n        mimeType.includes('officedocument') ||\n        mimeType.includes('csv') ||\n        mimeType.includes('text/plain');\n      \n      if (isDocument) {\n        allResults.push({\n          json: {\n            messageId: messageId,\n            emailFrom: emailFrom,\n            emailSubject: emailSubject,\n            emailDate: emailDate,\n            filename: filename,\n            mimeType: mimeType,\n            fileSize: fileSize\n          },\n          binary: {\n            data: attachment\n          }\n        });\n        console.log(`    ‚úÖ ADDED to results`);\n      } else {\n        console.log(`    ‚è≠Ô∏è  SKIPPED (not a document)`);\n      }\n    }\n  }\n  \n  console.log(`\\nüìä TOTAL DOCUMENTS: ${allResults.length}`);\n  \n  if (allResults.length === 0) {\n    console.log('‚ö†Ô∏è  Returning empty array - no documents found');\n  }\n  \n  return allResults;\n  \n} catch (error) {\n  console.error('‚ùå ERROR in extraction:', error.message);\n  console.error('Stack:', error.stack);\n  throw error;\n}"
      },
      "id": "extract-attachments",
      "name": "Extract Document Attachments",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 200]
    },
    {
      "parameters": {
        "url": "http://host.docker.internal:8000/api/documents/upload",
        "method": "POST",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "file",
              "value": "",
              "parameterType": "formBinaryData",
              "inputDataFieldName": "=data"
            }
          ]
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "email_from",
              "value": "={{$json.emailFrom}}"
            },
            {
              "name": "email_subject",
              "value": "={{$json.emailSubject}}"
            },
            {
              "name": "source",
              "value": "gmail_n8n"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "fullResponse": true,
              "neverError": false,
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "send-to-fastapi",
      "name": "Upload to FastAPI Backend",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1050, 200]
    },
    {
      "parameters": {
        "jsCode": "// Log the result from FastAPI and preserve messageId\nconst items = $input.all();\n\nfor (const item of items) {\n  const response = item.json.body || item.json;\n  const originalData = item.json;\n  \n  console.log('\\n‚úÖ Document uploaded:');\n  console.log('   Filename:', originalData.filename || response.filename || 'N/A');\n  console.log('   Document ID:', response.document_id || response.id || 'N/A');\n  console.log('   Status:', response.status || 'success');\n  console.log('   Department:', response.department || 'pending');\n  console.log('   MinIO Path:', response.minio_path || response.object_path || 'N/A');\n}\n\n// Preserve messageId for read marking\nreturn items.map(item => ({\n  json: {\n    ...item.json,\n    messageId: item.json.messageId,\n    status: item.json.body?.status || item.json.status || 'success',\n    document_id: item.json.body?.document_id || item.json.document_id\n  }\n}));"
      },
      "id": "log-results",
      "name": "Log Upload Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 200]
    },
    {
      "parameters": {
        "jsCode": "// Prepare data for marking email as read\nconst results = $input.all();\n\nif (!results || results.length === 0) {\n  return [];\n}\n\nconst summary = {\n  total_processed: results.length,\n  successful: results.filter(r => r.json.status !== 'error').length,\n  failed: results.filter(r => r.json.status === 'error').length,\n  timestamp: new Date().toISOString()\n};\n\nconsole.log('\\nüìä Upload Summary:', JSON.stringify(summary, null, 2));\n\n// Get the messageId from the first result to mark email as read\nconst firstResult = results[0];\nconst messageId = firstResult.json.messageId || firstResult.json.message_id;\n\nreturn [{\n  json: {\n    ...summary,\n    messageId: messageId,\n    status: 'ready_to_mark_read'\n  }\n}];"
      },
      "id": "final-processing",
      "name": "Prepare for Read Marking",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 200]
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "removeLabel",
        "messageId": "={{$json.messageId}}",
        "labelIds": ["UNREAD"]
      },
      "id": "mark-read",
      "name": "Mark Email as Read",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2,
      "position": [1650, 200]
    },
    {
      "parameters": {
        "jsCode": "const item = $input.first();\nconst json = item.json;\n\nconsole.log('\\n‚úÖ Email marked as READ');\nconsole.log('   Message ID:', json.messageId || 'N/A');\nconsole.log('   Documents processed:', json.total_processed || 0);\nconsole.log('   Successful uploads:', json.successful || 0);\nif (json.failed && json.failed > 0) {\n  console.log('   ‚ö†Ô∏è  Failed uploads:', json.failed);\n}\nconsole.log('   Timestamp:', json.timestamp || new Date().toISOString());\nconsole.log('\\n' + '='.repeat(50) + '\\n');\n\nreturn [item];"
      },
      "id": "log-completion",
      "name": "Log Email Completed",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1850, 200]
    },
    {
      "parameters": {
        "jsCode": "// No attachments found - extract messageId from email data\nconst emailData = $input.first().json;\nconst messageId = emailData.id || emailData.messageId;\n\nconsole.log('\\n‚ö†Ô∏è  Email has no document attachments');\nconsole.log('   From:', emailData.From || emailData.from);\nconsole.log('   Subject:', emailData.Subject || emailData.subject);\nconsole.log('   Message ID:', messageId);\nconsole.log('   Action: Marking as read to skip in future\\n');\n\nreturn [{\n  json: {\n    messageId: messageId,\n    status: 'no_attachments',\n    skipReason: 'no_document_attachments'\n  }\n}];"
      },
      "id": "no-attachments",
      "name": "No Attachments Found",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 400]
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "removeLabel",
        "messageId": "={{$json.messageId}}",
        "labelIds": ["UNREAD"]
      },
      "id": "mark-read-no-attach",
      "name": "Mark as Read (No Attachments)",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2,
      "position": [1050, 400]
    },
    {
      "parameters": {
        "jsCode": "console.log('‚úÖ Email marked as read (no attachments)\\n');\nreturn [];"
      },
      "id": "log-skipped",
      "name": "Log Skipped",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 400]
    }
  ],
  "connections": {
    "Gmail Trigger - Unread KMRL": {
      "main": [
        [
          {
            "node": "Filter - Has Attachments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter - Has Attachments": {
      "main": [
        [
          {
            "node": "Extract Document Attachments",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Attachments Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Document Attachments": {
      "main": [
        [
          {
            "node": "Upload to FastAPI Backend",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload to FastAPI Backend": {
      "main": [
        [
          {
            "node": "Log Upload Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Upload Results": {
      "main": [
        [
          {
            "node": "Prepare for Read Marking",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for Read Marking": {
      "main": [
        [
          {
            "node": "Mark Email as Read",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Email as Read": {
      "main": [
        [
          {
            "node": "Log Email Completed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Attachments Found": {
      "main": [
        [
          {
            "node": "Mark as Read (No Attachments)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark as Read (No Attachments)": {
      "main": [
        [
          {
            "node": "Log Skipped",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2026-01-23T00:00:00.000Z",
  "versionId": "1"
}
