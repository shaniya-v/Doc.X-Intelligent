{
  "name": "Doc.X Gmail Processor - Unread with Read Marking",
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "filters": {
          "includeLabels": ["KMRL", "UNREAD"]
        },
        "options": {
          "downloadAttachments": true,
          "q": "has:attachment label:KMRL is:unread"
        }
      },
      "id": "gmail-trigger",
      "name": "Gmail Trigger - Unread KMRL",
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1,
      "position": [250, 300]
    },

    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{Object.keys($binary).length}}",
              "operation": "isNotEmpty"
            }
          ]
        }
      },
      "id": "filter-attachments",
      "name": "Filter - Has Attachments",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "jsCode": "// DEBUG: Log everything first\nconst item = $input.first();\nconst data = item.json;\nconst binary = item.binary || {};\n\nconsole.log('\\nüîç DEBUG: Full item structure:');\nconsole.log('Binary keys:', Object.keys(binary));\nconsole.log('JSON keys:', Object.keys(data));\nconsole.log('Has payload?', !!data.payload);\nconsole.log('Has attachments array?', !!data.attachments);\n\n// If there ARE binary attachments, log them\nif (Object.keys(binary).length > 0) {\n  console.log('\\nüìé BINARY ATTACHMENTS FOUND!');\n  for (const [key, att] of Object.entries(binary)) {\n    console.log(`  - ${key}:`, att.fileName || att.filename, att.mimeType, att.fileSize);\n  }\n}\n\n// Extract email metadata\nfunction safeString(value) {\n  if (value === undefined || value === null) return '';\n  try { return String(value).trim(); } catch { return ''; }\n}\n\nfunction extractFrom(from) {\n  if (!from) return 'Unknown';\n  if (typeof from === 'string') return from;\n  if (from.text) return from.text;\n  if (from.value && Array.isArray(from.value) && from.value[0]) {\n    const v = from.value[0];\n    return v.name && v.address ? `${v.name} <${v.address}>` : v.address || v.name || 'Unknown';\n  }\n  return from.address || from.name || 'Unknown';\n}\n\nconst emailFrom = safeString(extractFrom(data.from || data.From));\nconst emailSubject = safeString(data.subject || data.Subject);\nconst emailDate = data.internalDate || data.date || new Date().toISOString();\nconst messageId = data.id || '';\nconst results = [];\n\nconsole.log('\\nüìß Processing:', emailSubject);\n\n// PROCESS ALL BINARY ATTACHMENTS\nfor (const [key, attachment] of Object.entries(binary)) {\n  if (!attachment) continue;\n  \n  const filename = attachment.fileName || attachment.filename || `file_${key}`;\n  const mimeType = attachment.mimeType || '';\n  const fileSize = attachment.fileSize || attachment.data?.length || 0;\n  \n  // Check if document\n  const isDoc = mimeType.includes('pdf') || \n                mimeType.includes('spreadsheet') || \n                mimeType.includes('document') || \n                mimeType.includes('excel') || \n                mimeType.includes('word') || \n                mimeType.includes('csv') || \n                mimeType.includes('text/plain') ||\n                filename.match(/\\.(pdf|docx?|xlsx?|xls|csv|txt)$/i);\n  \n  if (isDoc) {\n    results.push({\n      json: {\n        filename,\n        mimeType,\n        emailSubject,\n        emailFrom,\n        emailDate,\n        messageId,\n        fileSize\n      },\n      binary: { data: attachment }\n    });\n    console.log(`‚úÖ Added: ${filename} (${(fileSize/1024).toFixed(1)} KB)`);\n  } else {\n    console.log(`‚è≠Ô∏è  Skipped: ${filename} (${mimeType})`);\n  }\n}\n\nconsole.log(`\\nüìä Total documents: ${results.length}`);\nreturn results;"
      },
      "id": "extract-attachments",
      "name": "Extract Document Attachments",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 200]
    },
    {
      "parameters": {
        "url": "http://host.docker.internal:8000/api/documents/upload",
        "method": "POST",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "file",
              "value": "",
              "parameterType": "formBinaryData",
              "inputDataFieldName": "=data"
            }
          ]
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "email_from",
              "value": "={{$json.emailFrom}}"
            },
            {
              "name": "email_subject",
              "value": "={{$json.emailSubject}}"
            },
            {
              "name": "source",
              "value": "gmail_n8n"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "fullResponse": true,
              "neverError": false,
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "send-to-fastapi",
      "name": "Upload to FastAPI Backend",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1050, 200]
    },
    {
      "parameters": {
        "jsCode": "// Log the result from FastAPI and preserve messageId\nconst items = $input.all();\n\nfor (const item of items) {\n  const response = item.json.body || item.json;\n  const originalData = item.json;\n  \n  console.log('\\n‚úÖ Document uploaded:');\n  console.log('   Filename:', originalData.filename || response.filename || 'N/A');\n  console.log('   Document ID:', response.document_id || response.id || 'N/A');\n  console.log('   Status:', response.status || 'success');\n  console.log('   Department:', response.department || 'pending');\n  console.log('   MinIO Path:', response.minio_path || response.object_path || 'N/A');\n}\n\n// Preserve messageId for read marking\nreturn items.map(item => ({\n  json: {\n    ...item.json,\n    messageId: item.json.messageId,\n    status: item.json.body?.status || item.json.status || 'success',\n    document_id: item.json.body?.document_id || item.json.document_id\n  }\n}));"
      },
      "id": "log-results",
      "name": "Log Upload Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 200]
    },
    {
      "parameters": {
        "jsCode": "// Prepare data for marking email as read\nconst results = $input.all();\n\nif (!results || results.length === 0) {\n  return [];\n}\n\nconst summary = {\n  total_processed: results.length,\n  successful: results.filter(r => r.json.status !== 'error').length,\n  failed: results.filter(r => r.json.status === 'error').length,\n  timestamp: new Date().toISOString()\n};\n\nconsole.log('\\nüìä Upload Summary:', JSON.stringify(summary, null, 2));\n\n// Get the messageId from the first result to mark email as read\nconst firstResult = results[0];\nconst messageId = firstResult.json.messageId || firstResult.json.message_id;\n\nreturn [{\n  json: {\n    ...summary,\n    messageId: messageId,\n    status: 'ready_to_mark_read'\n  }\n}];"
      },
      "id": "final-processing",
      "name": "Prepare for Read Marking",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 200]
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "removeLabel",
        "messageId": "={{$json.messageId}}",
        "labelIds": ["UNREAD"]
      },
      "id": "mark-read",
      "name": "Mark Email as Read",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2,
      "position": [1650, 200]
    },
    {
      "parameters": {
        "jsCode": "const item = $input.first();\nconst json = item.json;\n\nconsole.log('\\n‚úÖ Email marked as READ');\nconsole.log('   Message ID:', json.messageId || 'N/A');\nconsole.log('   Documents processed:', json.total_processed || 0);\nconsole.log('   Successful uploads:', json.successful || 0);\nif (json.failed && json.failed > 0) {\n  console.log('   ‚ö†Ô∏è  Failed uploads:', json.failed);\n}\nconsole.log('   Timestamp:', json.timestamp || new Date().toISOString());\nconsole.log('\\n' + '='.repeat(50) + '\\n');\n\nreturn [item];"
      },
      "id": "log-completion",
      "name": "Log Email Completed",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1850, 200]
    },
    {
      "parameters": {
        "jsCode": "// No attachments found - extract messageId from email data\nconst emailData = $input.first().json;\nconst messageId = emailData.id || emailData.messageId;\n\nconsole.log('\\n‚ö†Ô∏è  Email has no document attachments');\nconsole.log('   From:', emailData.From || emailData.from);\nconsole.log('   Subject:', emailData.Subject || emailData.subject);\nconsole.log('   Message ID:', messageId);\nconsole.log('   Action: Marking as read to skip in future\\n');\n\nreturn [{\n  json: {\n    messageId: messageId,\n    status: 'no_attachments',\n    skipReason: 'no_document_attachments'\n  }\n}];"
      },
      "id": "no-attachments",
      "name": "No Attachments Found",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 400]
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "removeLabel",
        "messageId": "={{$json.messageId}}",
        "labelIds": ["UNREAD"]
      },
      "id": "mark-read-no-attach",
      "name": "Mark as Read (No Attachments)",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2,
      "position": [1050, 400]
    },
    {
      "parameters": {
        "jsCode": "console.log('‚úÖ Email marked as read (no attachments)\\n');\nreturn [];"
      },
      "id": "log-skipped",
      "name": "Log Skipped",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 400]
    }
  ],
  "connections": {
    "Gmail Trigger - Unread KMRL": {
      "main": [
        [
          {
            "node": "Filter - Has Attachments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter - Has Attachments": {
      "main": [
        [
          {
            "node": "Extract Document Attachments",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Attachments Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Document Attachments": {
      "main": [
        [
          {
            "node": "Upload to FastAPI Backend",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload to FastAPI Backend": {
      "main": [
        [
          {
            "node": "Log Upload Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Upload Results": {
      "main": [
        [
          {
            "node": "Prepare for Read Marking",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for Read Marking": {
      "main": [
        [
          {
            "node": "Mark Email as Read",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Email as Read": {
      "main": [
        [
          {
            "node": "Log Email Completed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Attachments Found": {
      "main": [
        [
          {
            "node": "Mark as Read (No Attachments)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark as Read (No Attachments)": {
      "main": [
        [
          {
            "node": "Log Skipped",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2026-01-23T00:00:00.000Z",
  "versionId": "1"
}
